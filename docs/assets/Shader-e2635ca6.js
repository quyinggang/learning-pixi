import{D as L,a7 as $,m as C,o as b}from"./index-b57fdfd1.js";const v=Object.create(null),D=Object.create(null);function w(r,e){let t=D[r];return t===void 0&&(v[e]===void 0&&(v[e]=1),D[r]=t=v[e]++),t}let g;function k(){return(!g||g!=null&&g.isContextLost())&&(g=L.get().createCanvas().getContext("webgl",{})),g}let h;function j(){if(!h){h="mediump";const r=k();r&&r.getShaderPrecisionFormat&&(h=r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision?"highp":"mediump")}return h}function W(r,e,t){return e?r:t?(r=r.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `}function H(r,e,t){const s=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if(r.substring(0,9)!=="precision"){let i=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return i==="highp"&&s!=="highp"&&(i="mediump"),`precision ${i} float;
${r}`}else if(s!=="highp"&&r.substring(0,15)==="precision highp")return r.replace("precision highp","precision mediump");return r}function q(r,e){return e?`#version 300 es
${r}`:r}const K={},X={};function I(r,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const s=t?K:X;return s[e]?(s[e]++,e+=`-${s[e]}`):s[e]=1,r.indexOf("#define SHADER_NAME")!==-1?r:`${`#define SHADER_NAME ${e}`}
${r}`}function Z(r,e){return e?r.replace("#version 300 es",""):r}const y={stripVersion:Z,ensurePrecision:H,addProgramDefines:W,setProgramName:I,insertVersion:q},P=Object.create(null),M=class A{constructor(e){e={...A.defaultOptions,...e};const t=e.fragment.indexOf("#version 300 es")!==-1,s={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:j()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let i=e.fragment,n=e.vertex;Object.keys(y).forEach(u=>{const o=s[u];i=y[u](i,o,!0),n=y[u](n,o,!1)}),this.fragment=i,this.vertex=n,this._key=w(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return P[t]||(P[t]=new A(e)),P[t]}};M.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let Y=M;const B={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function J(r){return B[r]??B.float32}const Q={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function ee({source:r,entryPoint:e}){const t={},s=r.indexOf(`fn ${e}`);if(s!==-1){const i=r.indexOf("->",s);if(i!==-1){const n=r.substring(s,i),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=u.exec(n))!==null;){const l=Q[o[3]]??"float32";t[o[2]]={location:parseInt(o[1],10),format:l,stride:J(l).stride,offset:0,instance:!1,start:0}}}}return t}function G(r){var f,d;const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,s=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,u=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,l=/struct\s+(\w+)/,c=(f=r.match(e))==null?void 0:f.map(m=>({group:parseInt(m.match(t)[1],10),binding:parseInt(m.match(s)[1],10),name:m.match(i)[2],isUniform:m.match(i)[1]==="<uniform>",type:m.match(n)[1]}));if(!c)return{groups:[],structs:[]};const a=((d=r.match(u))==null?void 0:d.map(m=>{const x=m.match(l)[1],F=m.match(o).reduce((O,R)=>{const[U,V]=R.split(":");return O[U.trim()]=V.trim(),O},{});return F?{name:x,members:F}:null}).filter(({name:m})=>c.some(x=>x.type===m)))??[];return{groups:c,structs:a}}var p=(r=>(r[r.VERTEX=1]="VERTEX",r[r.FRAGMENT=2]="FRAGMENT",r[r.COMPUTE=4]="COMPUTE",r))(p||{});function te({groups:r}){const e=[];for(let t=0;t<r.length;t++){const s=r[t];e[s.group]||(e[s.group]=[]),s.isUniform?e[s.group].push({binding:s.binding,visibility:p.VERTEX|p.FRAGMENT,buffer:{type:"uniform"}}):s.type==="sampler"?e[s.group].push({binding:s.binding,visibility:p.FRAGMENT,sampler:{type:"filtering"}}):s.type==="texture_2d"&&e[s.group].push({binding:s.binding,visibility:p.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}function re({groups:r}){const e=[];for(let t=0;t<r.length;t++){const s=r[t];e[s.group]||(e[s.group]={}),e[s.group][s.name]=s.binding}return e}function se(r,e){const t=new Set,s=new Set,i=[...r.structs,...e.structs].filter(u=>t.has(u.name)?!1:(t.add(u.name),!0)),n=[...r.groups,...e.groups].filter(u=>{const o=`${u.name}-${u.binding}`;return s.has(o)?!1:(s.add(o),!0)});return{structs:i,groups:n}}const _=Object.create(null);class z{constructor(e){var o,l;this._layoutKey=0;const{fragment:t,vertex:s,layout:i,gpuLayout:n,name:u}=e;if(this.name=u,this.fragment=t,this.vertex=s,t.source===s.source){const c=G(t.source);this.structsAndGroups=c}else{const c=G(s.source),a=G(t.source);this.structsAndGroups=se(c,a)}this.layout=i??re(this.structsAndGroups),this.gpuLayout=n??te(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((l=this.layout[1])==null?void 0:l.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,s=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=w(s,"program")}get attributeData(){return this._attributeData??(this._attributeData=ee(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return _[t]||(_[t]=new z(e)),_[t]}}function ie(r,e){switch(r){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const S=class T{constructor(e,t){this._touched=0,this.uid=$("uniform"),this._resourceType="uniformGroup",this._resourceId=$("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,t={...T.defaultOptions,...t},this.uniformStructures=e;const s={};for(const i in e){const n=e[i];n.name=i,n.size=n.size??1,n.value??(n.value=ie(n.type,n.size)),s[i]=n.value}this.uniforms=s,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=w(Object.keys(s).map(i=>`${i}-${e[i].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};S.defaultOptions={ubo:!1,isStatic:!1};let ne=S;var E=(r=>(r[r.WEBGL=1]="WEBGL",r[r.WEBGPU=2]="WEBGPU",r[r.BOTH=3]="BOTH",r))(E||{});class N extends C{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:t,glProgram:s,groups:i,resources:n,compatibleRenderers:u,groupMap:o}=e;this.gpuProgram=t,this.glProgram=s,u===void 0&&(u=0,t&&(u|=E.WEBGPU),s&&(u|=E.WEBGL)),this.compatibleRenderers=u;const l={};if(!n&&!i&&(n={}),n&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&i&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&i&&o)for(const c in o)for(const a in o[c]){const f=o[c][a];l[f]={group:c,binding:a,name:f}}else if(t&&i&&!o){const c=t.structsAndGroups.groups;o={},c.forEach(a=>{o[a.group]=o[a.group]||{},o[a.group][a.binding]=a.name,l[a.name]=a})}else if(n){if(t){const c=t.structsAndGroups.groups;o={},c.forEach(a=>{o[a.group]=o[a.group]||{},o[a.group][a.binding]=a.name,l[a.name]=a})}else{o={},i={99:new b},this._ownedBindGroups.push(i[99]);let c=0;for(const a in n)l[a]={group:99,binding:c,name:a},o[99]=o[99]||{},o[99][c]=a,c++}i={};for(const c in n){const a=c;let f=n[c];!f.source&&!f._resourceType&&(f=new ne(f));const d=l[a];d&&(i[d.group]||(i[d.group]=new b,this._ownedBindGroups.push(i[d.group])),i[d.group].setResource(f,d.binding))}}this.groups=i,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(i,l)}addResource(e,t,s){var i,n;(i=this._uniformBindMap)[t]||(i[t]={}),(n=this._uniformBindMap[t])[s]||(n[s]=e),this.groups[t]||(this.groups[t]=new b,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const s={};for(const i in t){const n=t[i];Object.defineProperty(s,n.name,{get(){return e[n.group].getResource(n.binding)},set(u){e[n.group].setResource(u,n.binding)}})}return s}destroy(e=!1){var t,s;this.emit("destroy",this),e&&((t=this.gpuProgram)==null||t.destroy(),(s=this.glProgram)==null||s.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(i=>{i.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:t,gl:s,...i}=e;let n,u;return t&&(n=z.from(t)),s&&(u=Y.from(s)),new N({gpuProgram:n,glProgram:u,...i})}}export{z as G,E as R,N as S,ne as U,Y as a,w as c,J as g};
