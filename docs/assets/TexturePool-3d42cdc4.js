import{D as X,a5 as N,h as Z,l as b,Z as Y,T as J,H as L}from"./index-b27a38ca.js";const y=Object.create(null),U=Object.create(null);function $(s,e){let t=U[s];return t===void 0&&(y[e]===void 0&&(y[e]=1),U[s]=t=y[e]++),t}let m;function Q(){return(!m||m!=null&&m.isContextLost())&&(m=X.get().createCanvas().getContext("webgl",{})),m}let p;function ee(){if(!p){p="mediump";const s=Q();s&&s.getShaderPrecisionFormat&&(p=s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision?"highp":"mediump")}return p}function te(s,e,t){return e?s:t?(s=s.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `}function re(s,e,t){const r=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if(s.substring(0,9)!=="precision"){let i=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return i==="highp"&&r!=="highp"&&(i="mediump"),`precision ${i} float;
${s}`}else if(r!=="highp"&&s.substring(0,15)==="precision highp")return s.replace("precision highp","precision mediump");return s}function se(s,e){return e?`#version 300 es
${s}`:s}const ie={},ne={};function oe(s,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const r=t?ie:ne;return r[e]?(r[e]++,e+=`-${r[e]}`):r[e]=1,s.indexOf("#define SHADER_NAME")!==-1?s:`${`#define SHADER_NAME ${e}`}
${s}`}function ae(s,e){return e?s.replace("#version 300 es",""):s}const P={stripVersion:ae,ensurePrecision:re,addProgramDefines:te,setProgramName:oe,insertVersion:se},_=Object.create(null),R=class T{constructor(e){e={...T.defaultOptions,...e};const t=e.fragment.indexOf("#version 300 es")!==-1,r={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:ee()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let i=e.fragment,n=e.vertex;Object.keys(P).forEach(a=>{const o=r[a];i=P[a](i,o,!0),n=P[a](n,o,!1)}),this.fragment=i,this.vertex=n,this._key=$(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return _[t]||(_[t]=new T(e)),_[t]}};R.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let ue=R;const C={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function le(s){return C[s]??C.float32}const ce={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function fe({source:s,entryPoint:e}){const t={},r=s.indexOf(`fn ${e}`);if(r!==-1){const i=s.indexOf("->",r);if(i!==-1){const n=s.substring(r,i),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=a.exec(n))!==null;){const u=ce[o[3]]??"float32";t[o[2]]={location:parseInt(o[1],10),format:u,stride:le(u).stride,offset:0,instance:!1,start:0}}}}return t}function v(s){var f,h;const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,a=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,u=/struct\s+(\w+)/,c=(f=s.match(e))==null?void 0:f.map(d=>({group:parseInt(d.match(t)[1],10),binding:parseInt(d.match(r)[1],10),name:d.match(i)[2],isUniform:d.match(i)[1]==="<uniform>",type:d.match(n)[1]}));if(!c)return{groups:[],structs:[]};const l=((h=s.match(a))==null?void 0:h.map(d=>{const x=d.match(u)[1],k=d.match(o).reduce((B,K)=>{const[I,q]=K.split(":");return B[I.trim()]=q.trim(),B},{});return k?{name:x,members:k}:null}).filter(({name:d})=>c.some(x=>x.type===d)))??[];return{groups:c,structs:l}}var g=(s=>(s[s.VERTEX=1]="VERTEX",s[s.FRAGMENT=2]="FRAGMENT",s[s.COMPUTE=4]="COMPUTE",s))(g||{});function de({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]=[]),r.isUniform?e[r.group].push({binding:r.binding,visibility:g.VERTEX|g.FRAGMENT,buffer:{type:"uniform"}}):r.type==="sampler"?e[r.group].push({binding:r.binding,visibility:g.FRAGMENT,sampler:{type:"filtering"}}):r.type==="texture_2d"&&e[r.group].push({binding:r.binding,visibility:g.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}function he({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]={}),e[r.group][r.name]=r.binding}return e}function me(s,e){const t=new Set,r=new Set,i=[...s.structs,...e.structs].filter(a=>t.has(a.name)?!1:(t.add(a.name),!0)),n=[...s.groups,...e.groups].filter(a=>{const o=`${a.name}-${a.binding}`;return r.has(o)?!1:(r.add(o),!0)});return{structs:i,groups:n}}const G=Object.create(null);class D{constructor(e){var o,u;this._layoutKey=0;const{fragment:t,vertex:r,layout:i,gpuLayout:n,name:a}=e;if(this.name=a,this.fragment=t,this.vertex=r,t.source===r.source){const c=v(t.source);this.structsAndGroups=c}else{const c=v(r.source),l=v(t.source);this.structsAndGroups=me(c,l)}this.layout=i??he(this.structsAndGroups),this.gpuLayout=n??de(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((u=this.layout[1])==null?void 0:u.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,r=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=$(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=fe(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return G[t]||(G[t]=new D(e)),G[t]}}function ge(s,e){switch(s){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const V=class H{constructor(e,t){this._touched=0,this.uid=N("uniform"),this._resourceType="uniformGroup",this._resourceId=N("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,t={...H.defaultOptions,...t},this.uniformStructures=e;const r={};for(const i in e){const n=e[i];n.name=i,n.size=n.size??1,n.value??(n.value=ge(n.type,n.size)),r[i]=n.value}this.uniforms=r,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=$(Object.keys(r).map(i=>`${i}-${e[i].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};V.defaultOptions={ubo:!1,isStatic:!1};let pe=V;var z=(s=>(s[s.WEBGL=1]="WEBGL",s[s.WEBGPU=2]="WEBGPU",s[s.BOTH=3]="BOTH",s))(z||{});class j extends Z{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:t,glProgram:r,groups:i,resources:n,compatibleRenderers:a,groupMap:o}=e;this.gpuProgram=t,this.glProgram=r,a===void 0&&(a=0,t&&(a|=z.WEBGPU),r&&(a|=z.WEBGL)),this.compatibleRenderers=a;const u={};if(!n&&!i&&(n={}),n&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&i&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&i&&o)for(const c in o)for(const l in o[c]){const f=o[c][l];u[f]={group:c,binding:l,name:f}}else if(t&&i&&!o){const c=t.structsAndGroups.groups;o={},c.forEach(l=>{o[l.group]=o[l.group]||{},o[l.group][l.binding]=l.name,u[l.name]=l})}else if(n){if(t){const c=t.structsAndGroups.groups;o={},c.forEach(l=>{o[l.group]=o[l.group]||{},o[l.group][l.binding]=l.name,u[l.name]=l})}else{o={},i={99:new b},this._ownedBindGroups.push(i[99]);let c=0;for(const l in n)u[l]={group:99,binding:c,name:l},o[99]=o[99]||{},o[99][c]=l,c++}i={};for(const c in n){const l=c;let f=n[c];!f.source&&!f._resourceType&&(f=new pe(f));const h=u[l];h&&(i[h.group]||(i[h.group]=new b,this._ownedBindGroups.push(i[h.group])),i[h.group].setResource(f,h.binding))}}this.groups=i,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(i,u)}addResource(e,t,r){var i,n;(i=this._uniformBindMap)[t]||(i[t]={}),(n=this._uniformBindMap[t])[r]||(n[r]=e),this.groups[t]||(this.groups[t]=new b,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const r={};for(const i in t){const n=t[i];Object.defineProperty(r,n.name,{get(){return e[n.group].getResource(n.binding)},set(a){e[n.group].setResource(a,n.binding)}})}return r}destroy(e=!1){var t,r;this.emit("destroy",this),e&&((t=this.gpuProgram)==null||t.destroy(),(r=this.glProgram)==null||r.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(i=>{i.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:t,gl:r,...i}=e;let n,a;return t&&(n=D.from(t)),r&&(a=ue.from(r)),new j({gpuProgram:n,glProgram:a,...i})}}const xe={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},w=0,F=1,E=2,A=3,O=4,M=5,S=class W{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<w)}set blend(e){!!(this.data&1<<w)!==e&&(this.data^=1<<w)}get offsets(){return!!(this.data&1<<F)}set offsets(e){!!(this.data&1<<F)!==e&&(this.data^=1<<F)}set cullMode(e){if(e==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=e==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<E)}set culling(e){!!(this.data&1<<E)!==e&&(this.data^=1<<E)}get depthTest(){return!!(this.data&1<<A)}set depthTest(e){!!(this.data&1<<A)!==e&&(this.data^=1<<A)}get depthMask(){return!!(this.data&1<<M)}set depthMask(e){!!(this.data&1<<M)!==e&&(this.data^=1<<M)}get clockwiseFrontFace(){return!!(this.data&1<<O)}set clockwiseFrontFace(e){!!(this.data&1<<O)!==e&&(this.data^=1<<O)}get blendMode(){return this._blendMode}set blendMode(e){this.blend=e!=="none",this._blendMode=e,this._blendModeId=xe[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new W;return e.depthTest=!1,e.blend=!0,e}};S.default2d=S.for2d();let _e=S,be=0;class ye{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1}createTexture(e,t,r){const i=new Y({...this.textureOptions,width:e,height:t,resolution:1,antialias:r,autoGarbageCollect:!0});return new J({source:i,label:`texturePool_${be++}`})}getOptimalTexture(e,t,r=1,i){let n=Math.ceil(e*r-1e-6),a=Math.ceil(t*r-1e-6);n=L(n),a=L(a);const o=(n<<17)+(a<<1)+(i?1:0);this._texturePool[o]||(this._texturePool[o]=[]);let u=this._texturePool[o].pop();return u||(u=this.createTexture(n,a,i)),u.source._resolution=r,u.source.width=n/r,u.source.height=a/r,u.source.pixelWidth=n,u.source.pixelHeight=a,u.frame.x=0,u.frame.y=0,u.frame.width=e,u.frame.height=t,u.updateUvs(),this._poolKeyHash[u.uid]=o,u}getSameSizeTexture(e,t=!1){const r=e.source;return this.getOptimalTexture(e.width,e.height,r._resolution,t)}returnTexture(e){const t=this._poolKeyHash[e.uid];this._texturePool[t].push(e)}clear(e){if(e=e!==!1,e)for(const t in this._texturePool){const r=this._texturePool[t];if(r)for(let i=0;i<r.length;i++)r[i].destroy(!0)}this._texturePool={}}}const ve=new ye;export{ue as G,z as R,_e as S,ve as T,pe as U,D as a,j as b,$ as c,le as g};
