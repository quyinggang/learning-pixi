import{D as L,a7 as T,m as k,o as b,$ as H,T as j,z as $}from"./index-c08b86c0.js";const P=Object.create(null),S=Object.create(null);function E(s,e){let t=S[s];return t===void 0&&(P[e]===void 0&&(P[e]=1),S[s]=t=P[e]++),t}let h;function W(){return(!h||h!=null&&h.isContextLost())&&(h=L.get().createCanvas().getContext("webgl",{})),h}let p;function K(){if(!p){p="mediump";const s=W();s&&s.getShaderPrecisionFormat&&(p=s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision?"highp":"mediump")}return p}function q(s,e,t){return e?s:t?(s=s.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `}function X(s,e,t){const r=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if(s.substring(0,9)!=="precision"){let i=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return i==="highp"&&r!=="highp"&&(i="mediump"),`precision ${i} float;
${s}`}else if(r!=="highp"&&s.substring(0,15)==="precision highp")return s.replace("precision highp","precision mediump");return s}function I(s,e){return e?`#version 300 es
${s}`:s}const Z={},Y={};function J(s,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const r=t?Z:Y;return r[e]?(r[e]++,e+=`-${r[e]}`):r[e]=1,s.indexOf("#define SHADER_NAME")!==-1?s:`${`#define SHADER_NAME ${e}`}
${s}`}function Q(s,e){return e?s.replace("#version 300 es",""):s}const y={stripVersion:Q,ensurePrecision:X,addProgramDefines:q,setProgramName:J,insertVersion:I},v=Object.create(null),B=class w{constructor(e){e={...w.defaultOptions,...e};const t=e.fragment.indexOf("#version 300 es")!==-1,r={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:K()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let i=e.fragment,n=e.vertex;Object.keys(y).forEach(u=>{const o=r[u];i=y[u](i,o,!0),n=y[u](n,o,!1)}),this.fragment=i,this.vertex=n,this._key=E(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return v[t]||(v[t]=new w(e)),v[t]}};B.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let ee=B;const D={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function te(s){return D[s]??D.float32}const re={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function se({source:s,entryPoint:e}){const t={},r=s.indexOf(`fn ${e}`);if(r!==-1){const i=s.indexOf("->",r);if(i!==-1){const n=s.substring(r,i),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=u.exec(n))!==null;){const a=re[o[3]]??"float32";t[o[2]]={location:parseInt(o[1],10),format:a,stride:te(a).stride,offset:0,instance:!1,start:0}}}}return t}function _(s){var f,d;const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,u=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,a=/struct\s+(\w+)/,l=(f=s.match(e))==null?void 0:f.map(m=>({group:parseInt(m.match(t)[1],10),binding:parseInt(m.match(r)[1],10),name:m.match(i)[2],isUniform:m.match(i)[1]==="<uniform>",type:m.match(n)[1]}));if(!l)return{groups:[],structs:[]};const c=((d=s.match(u))==null?void 0:d.map(m=>{const x=m.match(a)[1],F=m.match(o).reduce((O,N)=>{const[R,V]=N.split(":");return O[R.trim()]=V.trim(),O},{});return F?{name:x,members:F}:null}).filter(({name:m})=>l.some(x=>x.type===m)))??[];return{groups:l,structs:c}}var g=(s=>(s[s.VERTEX=1]="VERTEX",s[s.FRAGMENT=2]="FRAGMENT",s[s.COMPUTE=4]="COMPUTE",s))(g||{});function ie({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]=[]),r.isUniform?e[r.group].push({binding:r.binding,visibility:g.VERTEX|g.FRAGMENT,buffer:{type:"uniform"}}):r.type==="sampler"?e[r.group].push({binding:r.binding,visibility:g.FRAGMENT,sampler:{type:"filtering"}}):r.type==="texture_2d"&&e[r.group].push({binding:r.binding,visibility:g.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}function ne({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]={}),e[r.group][r.name]=r.binding}return e}function oe(s,e){const t=new Set,r=new Set,i=[...s.structs,...e.structs].filter(u=>t.has(u.name)?!1:(t.add(u.name),!0)),n=[...s.groups,...e.groups].filter(u=>{const o=`${u.name}-${u.binding}`;return r.has(o)?!1:(r.add(o),!0)});return{structs:i,groups:n}}const G=Object.create(null);class z{constructor(e){var o,a;this._layoutKey=0;const{fragment:t,vertex:r,layout:i,gpuLayout:n,name:u}=e;if(this.name=u,this.fragment=t,this.vertex=r,t.source===r.source){const l=_(t.source);this.structsAndGroups=l}else{const l=_(r.source),c=_(t.source);this.structsAndGroups=oe(l,c)}this.layout=i??ne(this.structsAndGroups),this.gpuLayout=n??ie(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((a=this.layout[1])==null?void 0:a.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,r=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=E(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=se(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return G[t]||(G[t]=new z(e)),G[t]}}function ue(s,e){switch(s){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const M=class U{constructor(e,t){this._touched=0,this.uid=T("uniform"),this._resourceType="uniformGroup",this._resourceId=T("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,t={...U.defaultOptions,...t},this.uniformStructures=e;const r={};for(const i in e){const n=e[i];n.name=i,n.size=n.size??1,n.value??(n.value=ue(n.type,n.size)),r[i]=n.value}this.uniforms=r,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=E(Object.keys(r).map(i=>`${i}-${e[i].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};M.defaultOptions={ubo:!1,isStatic:!1};let ae=M;var A=(s=>(s[s.WEBGL=1]="WEBGL",s[s.WEBGPU=2]="WEBGPU",s[s.BOTH=3]="BOTH",s))(A||{});class C extends k{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:t,glProgram:r,groups:i,resources:n,compatibleRenderers:u,groupMap:o}=e;this.gpuProgram=t,this.glProgram=r,u===void 0&&(u=0,t&&(u|=A.WEBGPU),r&&(u|=A.WEBGL)),this.compatibleRenderers=u;const a={};if(!n&&!i&&(n={}),n&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&i&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&i&&o)for(const l in o)for(const c in o[l]){const f=o[l][c];a[f]={group:l,binding:c,name:f}}else if(t&&i&&!o){const l=t.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,a[c.name]=c})}else if(n){if(t){const l=t.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,a[c.name]=c})}else{o={},i={99:new b},this._ownedBindGroups.push(i[99]);let l=0;for(const c in n)a[c]={group:99,binding:l,name:c},o[99]=o[99]||{},o[99][l]=c,l++}i={};for(const l in n){const c=l;let f=n[l];!f.source&&!f._resourceType&&(f=new ae(f));const d=a[c];d&&(i[d.group]||(i[d.group]=new b,this._ownedBindGroups.push(i[d.group])),i[d.group].setResource(f,d.binding))}}this.groups=i,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(i,a)}addResource(e,t,r){var i,n;(i=this._uniformBindMap)[t]||(i[t]={}),(n=this._uniformBindMap[t])[r]||(n[r]=e),this.groups[t]||(this.groups[t]=new b,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const r={};for(const i in t){const n=t[i];Object.defineProperty(r,n.name,{get(){return e[n.group].getResource(n.binding)},set(u){e[n.group].setResource(u,n.binding)}})}return r}destroy(e=!1){var t,r;this.emit("destroy",this),e&&((t=this.gpuProgram)==null||t.destroy(),(r=this.glProgram)==null||r.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(i=>{i.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:t,gl:r,...i}=e;let n,u;return t&&(n=z.from(t)),r&&(u=ee.from(r)),new C({gpuProgram:n,glProgram:u,...i})}}let ce=0;class le{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1}createTexture(e,t,r){const i=new H({...this.textureOptions,width:e,height:t,resolution:1,antialias:r,autoGarbageCollect:!0});return new j({source:i,label:`texturePool_${ce++}`})}getOptimalTexture(e,t,r=1,i){let n=Math.ceil(e*r-1e-6),u=Math.ceil(t*r-1e-6);n=$(n),u=$(u);const o=(n<<17)+(u<<1)+(i?1:0);this._texturePool[o]||(this._texturePool[o]=[]);let a=this._texturePool[o].pop();return a||(a=this.createTexture(n,u,i)),a.source._resolution=r,a.source.width=n/r,a.source.height=u/r,a.source.pixelWidth=n,a.source.pixelHeight=u,a.frame.x=0,a.frame.y=0,a.frame.width=e,a.frame.height=t,a.updateUvs(),this._poolKeyHash[a.uid]=o,a}getSameSizeTexture(e,t=!1){const r=e.source;return this.getOptimalTexture(e.width,e.height,r._resolution,t)}returnTexture(e){const t=this._poolKeyHash[e.uid];this._texturePool[t].push(e)}clear(e){if(e=e!==!1,e)for(const t in this._texturePool){const r=this._texturePool[t];if(r)for(let i=0;i<r.length;i++)r[i].destroy(!0)}this._texturePool={}}}const me=new le;export{z as G,A as R,C as S,me as T,ae as U,ee as a,E as c,te as g};
