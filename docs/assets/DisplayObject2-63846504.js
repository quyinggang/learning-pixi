import{P as Y,C as A,b as v,d as P,v as b,T as f,S as I,c as T,U as X,M as G,O as y,e as O,f as g,A as E,g as $}from"./index-df899187.js";import{A as U}from"./Assets-ee56c1d8.js";import{A as j,e as z}from"./AbstractText-66e03a5a.js";import{T as W}from"./TextStyle-fd6710f0.js";import{M as R,B as q,P as J}from"./PlaneGeometry-a218ddcb.js";import{S as K}from"./State-93d76a17.js";import{r as N,o as Q,a as Z,c as tt}from"./index-024bd686.js";import"./CanvasPool-d1c270f2.js";const C=new Y;class M extends A{constructor(...t){let e=t[0];e instanceof v&&(P(b,"Mesh: use new Mesh({ geometry, shader }) instead"),e={geometry:e,shader:t[1]},t[3]&&(P(b,"Mesh: drawMode argument has been removed, use geometry.topology instead"),e.geometry.topology=t[3]));const{geometry:i,shader:s,texture:r,roundPixels:o,state:d,...c}=e;super({label:"Mesh",...c}),this.renderPipeId="mesh",this.canBundle=!0,this._roundPixels=0,this.allowChildren=!1,this.shader=s,this.texture=r??(s==null?void 0:s.texture)??f.WHITE,this.state=d??K.for2d(),this._geometry=i,this._geometry.on("update",this.onViewUpdate,this),this.roundPixels=o??!1}get roundPixels(){return!!this._roundPixels}set roundPixels(t){this._roundPixels=t?1:0}get material(){return P(b,"mesh.material property has been removed, use mesh.shader instead"),this._shader}set shader(t){this._shader!==t&&(this._shader=t,this.onViewUpdate())}get shader(){return this._shader}set geometry(t){var e;this._geometry!==t&&((e=this._geometry)==null||e.off("update",this.onViewUpdate,this),t.on("update",this.onViewUpdate,this),this._geometry=t,this.onViewUpdate())}get geometry(){return this._geometry}set texture(t){t||(t=f.EMPTY);const e=this._texture;e!==t&&(e&&e.dynamic&&e.off("update",this.onViewUpdate,this),t.dynamic&&t.on("update",this.onViewUpdate,this),this.shader&&(this.shader.texture=t),this._texture=t,this.onViewUpdate())}get texture(){return this._texture}get batched(){return this._shader?!1:this._geometry instanceof R?this._geometry.batchMode==="auto"?this._geometry.positions.length/2<=100:this._geometry.batchMode==="batch":!1}get bounds(){return this._geometry.bounds}addBounds(t){t.addBounds(this.geometry.bounds)}containsPoint(t){const{x:e,y:i}=t;if(!this.bounds.containsPoint(e,i))return!1;const s=this.geometry.getBuffer("aPosition").data,r=C.points,o=this.geometry.getIndex().data,d=o.length,c=this.geometry.topology==="triangle-strip"?3:1;for(let l=0;l+2<d;l+=c){const n=o[l]*2,a=o[l+1]*2,h=o[l+2]*2;if(r[0]=s[n],r[1]=s[n+1],r[2]=s[a],r[3]=s[a+1],r[4]=s[h],r[5]=s[h+1],C.contains(e,i))return!0}return!1}onViewUpdate(){this._didChangeId+=1<<12,!this.didViewUpdate&&(this.didViewUpdate=!0,this.renderGroup&&this.renderGroup.onChildViewUpdate(this))}destroy(t){var i;if(super.destroy(t),typeof t=="boolean"?t:t==null?void 0:t.texture){const s=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._texture.destroy(s)}(i=this._geometry)==null||i.off("update",this.onViewUpdate,this),this._texture=null,this._geometry=null,this._shader=null}}class F extends I{constructor(t,e=!0){super(t[0]instanceof f?t[0]:t[0].texture),this._textures=null,this._durations=null,this._autoUpdate=e,this._isConnectedToTicker=!1,this.animationSpeed=1,this.loop=!0,this.updateAnchor=!1,this.onComplete=null,this.onFrameChange=null,this.onLoop=null,this._currentTime=0,this._playing=!1,this._previousFrame=null,this.textures=t}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(T.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(T.shared.add(this.update,this,X.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(t){this.stop(),this.currentFrame=t}gotoAndPlay(t){this.currentFrame=t,this.play()}update(t){if(!this._playing)return;const e=t.deltaTime,i=this.animationSpeed*e,s=this.currentFrame;if(this._durations!==null){let r=this._currentTime%1*this._durations[this.currentFrame];for(r+=i/60*1e3;r<0;)this._currentTime--,r+=this._durations[this.currentFrame];const o=Math.sign(this.animationSpeed*e);for(this._currentTime=Math.floor(this._currentTime);r>=this._durations[this.currentFrame];)r-=this._durations[this.currentFrame]*o,this._currentTime+=o;this._currentTime+=r/this._durations[this.currentFrame]}else this._currentTime+=i;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):s!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<s||this.animationSpeed<0&&this.currentFrame>s)&&this.onLoop(),this._updateTexture())}_updateTexture(){const t=this.currentFrame;this._previousFrame!==t&&(this._previousFrame=t,this.texture=this._textures[t],this.updateAnchor&&this.anchor.copyFrom(this.texture.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(){this.stop(),super.destroy(),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}static fromFrames(t){const e=[];for(let i=0;i<t.length;++i)e.push(f.from(t[i]));return new F(e)}static fromImages(t){const e=[];for(let i=0;i<t.length;++i)e.push(f.from(t[i]));return new F(e)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(t){if(t[0]instanceof f)this._textures=t,this._durations=null;else{this._textures=[],this._durations=[];for(let e=0;e<t.length;e++)this._textures.push(t[e].texture),this._durations.push(t[e].time)}this._previousFrame=null,this.gotoAndStop(0),this._updateTexture()}get currentFrame(){let t=Math.floor(this._currentTime)%this._textures.length;return t<0&&(t+=this._textures.length),t}set currentFrame(t){if(t<0||t>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this._updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(T.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(T.shared.add(this.update,this),this._isConnectedToTicker=!0))}}class et{constructor({matrix:t,observer:e}={}){this.dirty=!0,this._matrix=t??new G,this.observer=e,this.position=new y(this,0,0),this.scale=new y(this,1,1),this.pivot=new y(this,0,0),this.skew=new y(this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1}get matrix(){const t=this._matrix;return this.dirty&&(t.a=this._cx*this.scale.x,t.b=this._sx*this.scale.x,t.c=this._cy*this.scale.y,t.d=this._sy*this.scale.y,t.tx=this.position.x-(this.pivot.x*t.a+this.pivot.y*t.c),t.ty=this.position.y-(this.pivot.x*t.b+this.pivot.y*t.d),this.dirty=!1),t}_onUpdate(t){var e;this.dirty=!0,t===this.skew&&this.updateSkew(),(e=this.observer)==null||e._onUpdate(this)}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this.dirty=!0}toString(){return`[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`}setFromMatrix(t){t.decompose(this),this.dirty=!0}get rotation(){return this._rotation}set rotation(t){this._rotation!==t&&(this._rotation=t,this._onUpdate(this.skew))}}const B=class S extends A{constructor(...t){let e=t[0]||{};e instanceof f&&(e={texture:e}),t.length>1&&(P(b,"use new TilingSprite({ texture, width:100, height:100 }) instead"),e.width=t[1],e.height=t[2]),e={...S.defaultOptions,...e};const{texture:i,anchor:s,tilePosition:r,tileScale:o,tileRotation:d,width:c,height:l,applyAnchorToTexture:n,roundPixels:a,...h}=e??{};super({label:"TilingSprite",...h}),this.renderPipeId="tilingSprite",this.canBundle=!0,this.batched=!0,this._roundPixels=0,this._bounds={minX:0,maxX:1,minY:0,maxY:0},this._boundsDirty=!0,this.allowChildren=!1,this._anchor=new y(this),this._applyAnchorToTexture=n,this.texture=i,this._width=c??i.width,this._height=l??i.height,this._tileTransform=new et({observer:{_onUpdate:()=>this.onViewUpdate()}}),s&&(this.anchor=s),this.tilePosition=r,this.tileScale=o,this.tileRotation=d,this.roundPixels=a??!1}static from(t,e={}){return typeof t=="string"?new S({texture:O.get(t),...e}):new S({texture:t,...e})}get clampMargin(){return this._texture.textureMatrix.clampMargin}set clampMargin(t){this._texture.textureMatrix.clampMargin=t}get anchor(){return this._anchor}set anchor(t){typeof t=="number"?this._anchor.set(t):this._anchor.copyFrom(t)}get tilePosition(){return this._tileTransform.position}set tilePosition(t){this._tileTransform.position.copyFrom(t)}get tileScale(){return this._tileTransform.scale}set tileScale(t){typeof t=="number"?this._tileTransform.scale.set(t):this._tileTransform.scale.copyFrom(t)}set tileRotation(t){this._tileTransform.rotation=t}get tileRotation(){return this._tileTransform.rotation}get tileTransform(){return this._tileTransform}get roundPixels(){return!!this._roundPixels}set roundPixels(t){this._roundPixels=t?1:0}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}set texture(t){t||(t=f.EMPTY);const e=this._texture;e!==t&&(e&&e.dynamic&&e.off("update",this.onViewUpdate,this),t.dynamic&&t.on("update",this.onViewUpdate,this),this._texture=t,this.onViewUpdate())}get texture(){return this._texture}set width(t){this._width=t,this.onViewUpdate()}get width(){return this._width}set height(t){this._height=t,this.onViewUpdate()}get height(){return this._height}_updateBounds(){const t=this._bounds,e=this._anchor,i=this._width,s=this._height;t.maxX=-e._x*i,t.minX=t.maxX+i,t.maxY=-e._y*s,t.minY=t.maxY+s}addBounds(t){const e=this.bounds;t.addFrame(e.minX,e.minY,e.maxX,e.maxY)}containsPoint(t){const e=this.bounds.minX,i=this.bounds.minY,s=-e*this._anchor._x;let r=0;return t.x>=s&&t.x<=s+e&&(r=-i*this._anchor._y,t.y>=r&&t.y<=r+i)}onViewUpdate(){this._boundsDirty=!0,this._didTilingSpriteUpdate=!0,this._didChangeId+=1<<12,!this.didViewUpdate&&(this.didViewUpdate=!0,this.renderGroup&&this.renderGroup.onChildViewUpdate(this))}destroy(t=!1){if(super.destroy(t),this._anchor=null,this._tileTransform=null,this._bounds=null,typeof t=="boolean"?t:t==null?void 0:t.texture){const i=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._texture.destroy(i)}this._texture=null}};B.defaultOptions={texture:f.EMPTY,anchor:{x:0,y:0},tilePosition:{x:0,y:0},tileScale:{x:1,y:1},tileRotation:0,applyAnchorToTexture:!1};let it=B;class st extends j{constructor(...t){var e;const i=z(t,"BitmapText");i.style??(i.style=i.style||{}),(e=i.style).fill??(e.fill=16777215),super(i,W),this.renderPipeId="bitmapText"}_updateBounds(){const t=this._bounds,e=this._style.padding,i=this._anchor,s=q.measureText(this.text,this._style),r=s.scale,o=s.offsetY*r,d=s.width*r,c=s.height*r;t.minX=-i._x*d-e,t.maxX=t.minX+d,t.minY=-i._y*(c+o)-e,t.maxY=t.minY+c}}class rt extends M{constructor(t){const{texture:e,verticesX:i,verticesY:s,...r}=t,o=new J(g({width:e.width,height:e.height,verticesX:i,verticesY:s}));super(g({...r,geometry:o,texture:e})),this.texture=e,this.autoResize=!0}textureUpdated(){const t=this.geometry,{width:e,height:i}=this.texture;this.autoResize&&(t.width!==e||t.height!==i)&&(t.width=e,t.height=i,t.build({}))}set texture(t){var e;(e=this._texture)==null||e.off("update",this.textureUpdated,this),super.texture=t,t.on("update",this.textureUpdated,this),this.textureUpdated()}get texture(){return this._texture}destroy(t){this.texture.off("update",this.textureUpdated,this),super.destroy(t)}}const D=class L extends R{constructor(t){const{width:e,points:i,textureScale:s}={...L.defaultOptions,...t};super({positions:new Float32Array(i.length*4),uvs:new Float32Array(i.length*4),indices:new Uint32Array((i.length-1)*6)}),this.points=i,this._width=e,this.textureScale=s,this._build()}get width(){return this._width}_build(){const t=this.points;if(!t)return;const e=this.getBuffer("aPosition"),i=this.getBuffer("aUV"),s=this.getIndex();if(t.length<1)return;e.data.length/4!==t.length&&(e.data=new Float32Array(t.length*4),i.data=new Float32Array(t.length*4),s.data=new Uint16Array((t.length-1)*6));const r=i.data,o=s.data;r[0]=0,r[1]=0,r[2]=0,r[3]=1;let d=0,c=t[0];const l=this._width*this.textureScale,n=t.length;for(let h=0;h<n;h++){const u=h*4;if(this.textureScale>0){const p=c.x-t[h].x,_=c.y-t[h].y,w=Math.sqrt(p*p+_*_);c=t[h],d+=w/l}else d=h/(n-1);r[u]=d,r[u+1]=0,r[u+2]=d,r[u+3]=1}let a=0;for(let h=0;h<n-1;h++){const u=h*2;o[a++]=u,o[a++]=u+1,o[a++]=u+2,o[a++]=u+2,o[a++]=u+1,o[a++]=u+3}i.update(),s.update(),this.updateVertices()}updateVertices(){const t=this.points;if(t.length<1)return;let e=t[0],i,s=0,r=0;const o=this.buffers[0].data,d=t.length,c=this.textureScale>0?this.textureScale*this._width/2:this._width/2;for(let l=0;l<d;l++){const n=t[l],a=l*4;l<t.length-1?i=t[l+1]:i=n,r=-(i.x-e.x),s=i.y-e.y;const h=Math.sqrt(s*s+r*r);h<1e-6?(s=0,r=0):(s/=h,r/=h,s*=c,r*=c),o[a]=n.x+s,o[a+1]=n.y+r,o[a+2]=n.x-s,o[a+3]=n.y-r,e=n}this.buffers[0].update()}update(){this.textureScale>0?this._build():this.updateVertices()}};D.defaultOptions={width:200,points:[],textureScale:0};let nt=D;const V=class H extends M{constructor(t){const{texture:e,points:i,textureScale:s,...r}={...H.defaultOptions,...t},o=new nt(g({width:e.height,points:i,textureScale:s}));s>0&&(e.source.style.addressMode="repeat"),super(g({...r,texture:e,geometry:o})),this.autoUpdate=!0,this.onRender=this._render}_render(){const t=this.geometry;(this.autoUpdate||t._width!==this.texture.height)&&(t._width=this.texture.height,t.update())}};V.defaultOptions={textureScale:0};let ot=V;class ht extends M{constructor(t){const{texture:e,vertices:i,uvs:s,indices:r,topology:o,...d}=t,c=new R(g({positions:i,uvs:s,indices:r,topology:o}));super(g({...d,texture:e,geometry:c})),this.autoUpdate=!0,this.onRender=this._render}get vertices(){return this.geometry.getBuffer("aPosition").data}set vertices(t){this.geometry.getBuffer("aPosition").data=t}_render(){this.autoUpdate&&this.geometry.getBuffer("aPosition").update()}}const k=""+new URL("1-4e41503c.png",import.meta.url).href,at=""+new URL("2-2c2135ef.png",import.meta.url).href,ut=""+new URL("3-01195b1c.png",import.meta.url).href,dt=""+new URL("4-96c0da45.png",import.meta.url).href,ct=""+new URL("5-692902c6.png",import.meta.url).href,lt=""+new URL("6-a278697a.png",import.meta.url).href,pt=""+new URL("7-3ecd4cd4.png",import.meta.url).href,mt=""+new URL("8-665c082f.png",import.meta.url).href,ft=""+new URL("9-feca5c89.png",import.meta.url).href,gt=""+new URL("10-ddfe3433.png",import.meta.url).href,xt=""+new URL("11-7238fbd1.png",import.meta.url).href,_t=""+new URL("12-40e888c0.png",import.meta.url).href,yt=""+new URL("13-9a8f1a4b.png",import.meta.url).href,wt=""+new URL("14-f28c1de3.png",import.meta.url).href,Tt=""+new URL("15-944d485f.png",import.meta.url).href,Ut=""+new URL("16-71db446a.png",import.meta.url).href,Pt=""+new URL("17-47a839f0.png",import.meta.url).href,bt=""+new URL("18-4a4108e5.png",import.meta.url).href,St=""+new URL("19-76a7e622.png",import.meta.url).href,Ft=""+new URL("20-e670d00e.png",import.meta.url).href,Rt=""+new URL("background-e34fcf73.png",import.meta.url).href,Ht={__name:"DisplayObject2",setup(x){const t=N(null),e=async(n,a)=>{const h=new E;return await h.init({width:n,height:a,antialias:!0,resolution:window.devicePixelRatio||1,autoDensity:!0}),h},i=async()=>{const n=[k,at,ut,dt,ct,lt,pt,mt,ft,gt,xt,_t,yt,wt,Tt,Ut,Pt,bt,St,Ft],a=await U.load(n),h=new F(Object.values(a));return h.width=90,h.height=90,h},s=async()=>{const n=await U.load(Rt);return new it({texture:n,width:n.width*.5,height:n.height*.5,tileScale:{x:.5,y:.5}})},r=()=>new st({text:`Hello Pixi!
 BitmapText`,style:{fontFamily:"Arial",fontSize:18,fill:16715792,align:"center"}}),o=()=>new ht({vertices:[0,30,30,-30,-30,-30],indices:[0,1,2,2,0,1]}),d=async()=>{const n=await U.load(k),a=new rt({texture:n,verticesX:20});return a.width=n.width*.3,a.height=n.height*.3,a},c=async()=>{const n=await U.load("https://pixijs.com/assets/snake.png"),a=918/20,h=[];for(let p=0;p<20;p++)h.push(new $(p*a,Math.sin(p*.5)*30));const u=new ot({texture:n,points:h});return u.scale.set(.5),u},l=async n=>{const{element:a,boundingRect:h}=n,u=await e(h.width,h.height);a.appendChild(u.canvas);const p={x:u.screen.width*.5,y:u.screen.height*.5};s().then(m=>{u.ticker.add(()=>{m.tilePosition.x-=.5}),u.stage.addChild(m)}),i().then(m=>{m.position.set(p.x,p.y*.5),u.stage.addChild(m),m.play()});const _=r();_.position.set(p.x,p.y),u.stage.addChild(_);const w=o();w.position.set(p.x*.5,p.y+30),u.stage.addChild(w),d().then(m=>{m.position.set(p.x*.5,p.y),u.stage.addChild(m)}),c().then(m=>{m.position.set(p.x*.1,p.y*1.5),u.stage.addChild(m)})};return Q(()=>{const n=t.value,a=n.getBoundingClientRect();l({element:n,boundingRect:a})}),(n,a)=>(Z(),tt("div",{ref_key:"boxElementRef",ref:t,class:"box"},null,512))}};export{Ht as default};
