import{E as h,T as $,w as u,c as _,p as x,i as G,L as B,D as m,e as p,R as E,I as V,a as Z,V as k,f as J,g as b}from"./index-e61fb7a8.js";class q{constructor(e,s=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=s}add(e){e.forEach(s=>{this._assetList.push(s)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],s=Math.min(this._assetList.length,this._maxConcurrent);for(let a=0;a<s;a++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}const ee={extension:h.CacheParser,test:t=>Array.isArray(t)&&t.every(e=>e instanceof $),getCacheableAssets:(t,e)=>{const s={};return t.forEach(a=>{e.forEach((r,o)=>{s[a+(o===0?"":o+1)]=r})}),s}};async function N(t){if("Image"in globalThis)return new Promise(e=>{const s=new Image;s.onload=()=>{e(!0)},s.onerror=()=>{e(!1)},s.src=t});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const e=await(await fetch(t)).blob();await createImageBitmap(e)}catch{return!1}return!0}return!1}const te={extension:{type:h.DetectionParser,priority:1},test:async()=>N("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async t=>[...t,"avif"],remove:async t=>t.filter(e=>e!=="avif")},F=["png","jpg","jpeg"],se={extension:{type:h.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async t=>[...t,...F],remove:async t=>t.filter(e=>!F.includes(e))},ae="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function I(t){return ae?!1:document.createElement("video").canPlayType(t)!==""}const re={extension:{type:h.DetectionParser,priority:0},test:async()=>I("video/mp4"),add:async t=>[...t,"mp4","m4v"],remove:async t=>t.filter(e=>e!=="mp4"&&e!=="m4v")},ie={extension:{type:h.DetectionParser,priority:0},test:async()=>I("video/ogg"),add:async t=>[...t,"ogv"],remove:async t=>t.filter(e=>e!=="ogv")},oe={extension:{type:h.DetectionParser,priority:0},test:async()=>I("video/webm"),add:async t=>[...t,"webm"],remove:async t=>t.filter(e=>e!=="webm")},ne={extension:{type:h.DetectionParser,priority:0},test:async()=>N("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async t=>[...t,"webp"],remove:async t=>t.filter(e=>e!=="webp")};class ce{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(e,s,a)=>(this._parsersValidated=!1,e[s]=a,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(e,s){const a={promise:null,parser:null};return a.promise=(async()=>{var n,i;let r=null,o=null;if(s.loadParser&&(o=this._parserHash[s.loadParser],o||u(`[Assets] specified load parser "${s.loadParser}" not found while loading ${e}`)),!o){for(let l=0;l<this.parsers.length;l++){const c=this.parsers[l];if(c.load&&((n=c.test)!=null&&n.call(c,e,s,this))){o=c;break}}if(!o)return u(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}r=await o.load(e,s,this),a.parser=o;for(let l=0;l<this.parsers.length;l++){const c=this.parsers[l];c.parse&&c.parse&&await((i=c.testParse)==null?void 0:i.call(c,r,s,this))&&(r=await c.parse(r,s,this)||r,a.parser=c)}return r})(),a}async load(e,s){this._parsersValidated||this._validateParsers();let a=0;const r={},o=G(e),n=_(e,c=>({alias:[c],src:c})),i=n.length,l=n.map(async c=>{const d=x.toAbsolute(c.src);if(!r[c.src])try{this.promiseCache[d]||(this.promiseCache[d]=this._getLoadPromiseAndParser(d,c)),r[c.src]=await this.promiseCache[d].promise,s&&s(++a/i)}catch(A){throw delete this.promiseCache[d],delete r[c.src],new Error(`[Loader.load] Failed to load ${d}.
${A}`)}});return await Promise.all(l),o?r[n[0].src]:r}async unload(e){const a=_(e,r=>({alias:[r],src:r})).map(async r=>{var i,l;const o=x.toAbsolute(r.src),n=this.promiseCache[o];if(n){const c=await n.promise;delete this.promiseCache[o],await((l=(i=n.parser)==null?void 0:i.unload)==null?void 0:l.call(i,c,r,this))}});await Promise.all(a)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(e=>e.name).reduce((e,s)=>(s.name?e[s.name]&&u(`[Assets] loadParser name conflict "${s.name}"`):u("[Assets] loadParser should have a name"),{...e,[s.name]:s}),{})}}function y(t,e){if(Array.isArray(e)){for(const s of e)if(t.startsWith(`data:${s}`))return!0;return!1}return t.startsWith(`data:${e}`)}function w(t,e){const s=t.split("?")[0],a=x.extname(s).toLowerCase();return Array.isArray(e)?e.includes(a):a===e}const le=".json",de="application/json",he={extension:{type:h.LoadParser,priority:B.Low},name:"loadJson",test(t){return y(t,de)||w(t,le)},async load(t){return await(await m.get().fetch(t)).json()}},Ae=".txt",fe="text/plain",pe={name:"loadTxt",extension:{type:h.LoadParser,priority:B.Low},test(t){return y(t,fe)||w(t,Ae)},async load(t){return await(await m.get().fetch(t)).text()}},ue=["normal","bold","100","200","300","400","500","600","700","800","900"],me=[".ttf",".otf",".woff",".woff2"],ge=["font/ttf","font/otf","font/woff","font/woff2"],ve=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function ye(t){const e=x.extname(t),r=x.basename(t,e).replace(/(-|_)/g," ").toLowerCase().split(" ").map(i=>i.charAt(0).toUpperCase()+i.slice(1));let o=r.length>0;for(const i of r)if(!i.match(ve)){o=!1;break}let n=r.join(" ");return o||(n=`"${n.replace(/[\\"]/g,"\\$&")}"`),n}const we=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function _e(t){return we.test(t)?t:encodeURI(t)}const be={extension:{type:h.LoadParser,priority:B.Low},name:"loadWebFont",test(t){return y(t,ge)||w(t,me)},async load(t,e){var a,r,o;const s=m.get().getFontFaceSet();if(s){const n=[],i=((a=e.data)==null?void 0:a.family)??ye(t),l=((o=(r=e.data)==null?void 0:r.weights)==null?void 0:o.filter(d=>ue.includes(d)))??["normal"],c=e.data??{};for(let d=0;d<l.length;d++){const A=l[d],f=new FontFace(i,`url(${_e(t)})`,{...c,weight:A});await f.load(),s.add(f),n.push(f)}return p.set(`${i}-and-url`,{url:t,fontFaces:n}),n.length===1?n[0]:n}return u("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(t){(Array.isArray(t)?t:[t]).forEach(e=>{p.remove(e.family),m.get().getFontFaceSet().delete(e)})}};function O(t,e=1){var a;const s=(a=E.RETINA_PREFIX)==null?void 0:a.exec(t);return s?parseFloat(s[1]):e}function W(t,e,s){t.label=s,t._sourceOrigin=s;const a=new $({source:t,label:s}),r=()=>{delete e.promiseCache[s],p.has(s)&&p.remove(s)};return a.source.once("destroy",()=>{e.promiseCache[s]&&(u("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),r())}),a.once("destroy",()=>{t.destroyed||(u("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),r())}),a}const xe=".svg",Be="image/svg+xml",Le={extension:{type:h.LoadParser,priority:B.Low},name:"loadSVG",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(t){return y(t,Be)||w(t,xe)},async load(t,e,s){return e.data.parseAsGraphicsContext??this.config.parseAsGraphicsContext?ke(t):Ee(t,e,s,this.config.crossOrigin)},unload(t){t.destroy(!0)}};async function Ee(t,e,s,a){var T,j,U;const o=await(await m.get().fetch(t)).blob(),n=URL.createObjectURL(o),i=new Image;i.src=n,i.crossOrigin=a,await i.decode(),URL.revokeObjectURL(n);const l=document.createElement("canvas"),c=l.getContext("2d"),d=((T=e.data)==null?void 0:T.resolution)||O(t),A=((j=e.data)==null?void 0:j.width)??i.width,f=((U=e.data)==null?void 0:U.height)??i.height;l.width=A*d,l.height=f*d,c.drawImage(i,0,0,A*d,f*d);const{parseAsGraphicsContext:C,...X}=e.data,Y=new V({resource:l,alphaMode:"premultiply-alpha-on-upload",resolution:d,...X});return W(Y,s,t)}async function ke(t){const s=await(await m.get().fetch(t)).text(),a=new Z;return a.svg(s),a}const Pe=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let g=null,R=class{constructor(){g||(g=URL.createObjectURL(new Blob([Pe],{type:"application/javascript"}))),this.worker=new Worker(g)}};R.revokeObjectURL=function(){g&&(URL.revokeObjectURL(g),g=null)};const Re=`(function () {
    'use strict';

    async function loadImageBitmap(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      const imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap;
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let v=null;class z{constructor(){v||(v=URL.createObjectURL(new Blob([Re],{type:"application/javascript"}))),this.worker=new Worker(v)}}z.revokeObjectURL=function(){v&&(URL.revokeObjectURL(v),v=null)};let M=0,P;class Ie{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(e=>{const{worker:s}=new R;s.addEventListener("message",a=>{s.terminate(),R.revokeObjectURL(),e(a.data)})}),this._isImageBitmapSupported)}loadImageBitmap(e){return this._run("loadImageBitmap",[e])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){P===void 0&&(P=navigator.hardwareConcurrency||4);let e=this._workerPool.pop();return!e&&this._createdWorkers<P&&(this._createdWorkers++,e=new z().worker,e.addEventListener("message",s=>{this._complete(s.data),this._returnWorker(s.target),this._next()})),e}_returnWorker(e){this._workerPool.push(e)}_complete(e){e.error!==void 0?this._resolveHash[e.uuid].reject(e.error):this._resolveHash[e.uuid].resolve(e.data),this._resolveHash[e.uuid]=null}async _run(e,s){await this._initWorkers();const a=new Promise((r,o)=>{this._queue.push({id:e,arguments:s,resolve:r,reject:o})});return this._next(),a}_next(){if(!this._queue.length)return;const e=this._getWorker();if(!e)return;const s=this._queue.pop(),a=s.id;this._resolveHash[M]={resolve:s.resolve,reject:s.reject},e.postMessage({data:s.arguments,uuid:M++,id:a})}}const S=new Ie,Oe=[".jpeg",".jpg",".png",".webp",".avif"],We=["image/jpeg","image/png","image/webp","image/avif"];async function Ce(t){const e=await m.get().fetch(t);if(!e.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`);const s=await e.blob();return await createImageBitmap(s)}const K={name:"loadTextures",extension:{type:h.LoadParser,priority:B.High},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(t){return y(t,We)||w(t,Oe)},async load(t,e,s){var o;let a=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await S.isImageBitmapSupported()?a=await S.loadImageBitmap(t):a=await Ce(t):a=await new Promise(n=>{a=new Image,a.crossOrigin=this.config.crossOrigin,a.src=t,a.complete?n(a):a.onload=()=>{n(a)}});const r=new V({resource:a,alphaMode:"premultiply-alpha-on-upload",resolution:((o=e.data)==null?void 0:o.resolution)||O(t),...e.data});return W(r,s,t)},unload(t){t.destroy(!0)}},H=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],Te=H.map(t=>`video/${t.substring(1)}`);function je(t,e,s){s===void 0&&!e.startsWith("data:")?t.crossOrigin=Fe(e):s!==!1&&(t.crossOrigin=typeof s=="string"?s:"anonymous")}function Ue(t){return new Promise((e,s)=>{t.addEventListener("canplaythrough",a),t.addEventListener("error",r),t.load();function a(){o(),e()}function r(n){o(),s(n)}function o(){t.removeEventListener("canplaythrough",a),t.removeEventListener("error",r)}})}function Fe(t,e=globalThis.location){if(t.startsWith("data:"))return"";e=e||globalThis.location;const s=new URL(t,document.baseURI);return s.hostname!==e.hostname||s.port!==e.port||s.protocol!==e.protocol?"anonymous":""}const Me={name:"loadVideo",extension:{type:h.LoadParser},config:null,test(t){const e=y(t,Te),s=w(t,H);return e||s},async load(t,e,s){var l,c;const a={...k.defaultOptions,resolution:((l=e.data)==null?void 0:l.resolution)||O(t),alphaMode:((c=e.data)==null?void 0:c.alphaMode)||await J(),...e.data},r=document.createElement("video"),o={preload:a.autoLoad!==!1?"auto":void 0,"webkit-playsinline":a.playsinline!==!1?"":void 0,playsinline:a.playsinline!==!1?"":void 0,muted:a.muted===!0?"":void 0,loop:a.loop===!0?"":void 0,autoplay:a.autoPlay!==!1?"":void 0};Object.keys(o).forEach(d=>{const A=o[d];A!==void 0&&r.setAttribute(d,A)}),a.muted===!0&&(r.muted=!0),je(r,t,a.crossorigin);const n=document.createElement("source");let i;if(t.startsWith("data:"))i=t.slice(5,t.indexOf(";"));else if(!t.startsWith("blob:")){const d=t.split("?")[0].slice(t.lastIndexOf(".")+1).toLowerCase();i=k.MIME_TYPES[d]||`video/${d}`}return n.src=t,i&&(n.type=i),new Promise(d=>{const A=async()=>{const f=new k({...a,resource:r});r.removeEventListener("canplay",A),e.data.preload&&await Ue(r),d(W(f,s,t))};r.addEventListener("canplay",A),r.appendChild(n)})},unload(t){t.destroy(!0)}},Q={extension:h.ResolveParser,test:K.test,parse:t=>{var e;return{resolution:parseFloat(((e=E.RETINA_PREFIX.exec(t))==null?void 0:e[1])??"1"),format:t.split(".").pop(),src:t}}},Se={extension:h.ResolveParser,test:t=>E.RETINA_PREFIX.test(t)&&t.endsWith(".json"),parse:Q.parse};class De{constructor(){this._detections=[],this._initialized=!1,this.resolver=new E,this.loader=new ce,this.cache=p,this._backgroundLoader=new q(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){var o,n;if(this._initialized){u("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams),e.basePath&&(this.resolver.basePath=e.basePath),e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier),e.manifest){let i=e.manifest;typeof i=="string"&&(i=await this.load(i)),this.resolver.addManifest(i)}const s=((o=e.texturePreference)==null?void 0:o.resolution)??1,a=typeof s=="number"?[s]:s,r=await this._detectFormats({preferredFormats:(n=e.texturePreference)==null?void 0:n.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:r,resolution:a}}),e.preferences&&this.setPreferences(e.preferences)}add(e){this.resolver.add(e)}async load(e,s){this._initialized||await this.init();const a=G(e),r=_(e).map(i=>{if(typeof i!="string"){const l=this.resolver.getAlias(i);return l.some(c=>!this.resolver.hasKey(c))&&this.add(i),Array.isArray(l)?l[0]:l}return this.resolver.hasKey(i)||this.add({alias:i,src:i}),i}),o=this.resolver.resolve(r),n=await this._mapLoadToResolve(o,s);return a?n[r[0]]:n}addBundle(e,s){this.resolver.addBundle(e,s)}async loadBundle(e,s){this._initialized||await this.init();let a=!1;typeof e=="string"&&(a=!0,e=[e]);const r=this.resolver.resolveBundle(e),o={},n=Object.keys(r);let i=0,l=0;const c=()=>{s==null||s(++i/l)},d=n.map(A=>{const f=r[A];return l+=Object.keys(f).length,this._mapLoadToResolve(f,c).then(C=>{o[A]=C})});return await Promise.all(d),a?o[e[0]]:o}async backgroundLoad(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const s=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(s))}async backgroundLoadBundle(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const s=this.resolver.resolveBundle(e);Object.values(s).forEach(a=>{this._backgroundLoader.add(Object.values(a))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if(typeof e=="string")return p.get(e);const s={};for(let a=0;a<e.length;a++)s[a]=p.get(e[a]);return s}async _mapLoadToResolve(e,s){const a=[...new Set(Object.values(e))];this._backgroundLoader.active=!1;const r=await this.loader.load(a,s);this._backgroundLoader.active=!0;const o={};return a.forEach(n=>{const i=r[n.src],l=[n.src];n.alias&&l.push(...n.alias),l.forEach(c=>{o[c]=i}),p.set(l,i)}),o}async unload(e){this._initialized||await this.init();const s=_(e).map(r=>typeof r!="string"?r.src:r),a=this.resolver.resolve(s);await this._unloadFromResolved(a)}async unloadBundle(e){this._initialized||await this.init(),e=_(e);const s=this.resolver.resolveBundle(e),a=Object.keys(s).map(r=>this._unloadFromResolved(s[r]));await Promise.all(a)}async _unloadFromResolved(e){const s=Object.values(e);s.forEach(a=>{p.remove(a.src)}),await this.loader.unload(s)}async _detectFormats(e){let s=[];e.preferredFormats&&(s=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const a of e.detections)e.skipDetections||await a.test()?s=await a.add(s):e.skipDetections||(s=await a.remove(s));return s=s.filter((a,r)=>s.indexOf(a)===r),s}get detections(){return this._detections}setPreferences(e){this.loader.parsers.forEach(s=>{s.config&&Object.keys(s.config).filter(a=>a in e).forEach(a=>{s.config[a]=e[a]})})}}const L=new De;b.handleByList(h.LoadParser,L.loader.parsers).handleByList(h.ResolveParser,L.resolver.parsers).handleByList(h.CacheParser,L.cache.parsers).handleByList(h.DetectionParser,L.detections);b.add(ee,se,te,ne,re,ie,oe,he,pe,be,Le,K,Me,Q,Se);const D={loader:h.LoadParser,resolver:h.ResolveParser,cache:h.CacheParser,detection:h.DetectionParser};b.handle(h.Asset,t=>{const e=t.ref;Object.entries(D).filter(([s])=>!!e[s]).forEach(([s,a])=>b.add(Object.assign(e[s],{extension:e[s].extension??a})))},t=>{const e=t.ref;Object.keys(D).filter(s=>!!e[s]).forEach(s=>b.remove(e[s]))});export{L as A};
