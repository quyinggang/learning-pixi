import{b as V,d as F,v as _,H as M,J as S,T as B,y as A,M as k,K as N,N as D,w as J,m as q,R as Z,I as Q,e as y}from"./index-c08b86c0.js";import{f as W,C as I,T as X}from"./TextStyle-3d9d7654.js";import{C as O}from"./CanvasPool-c947f36f.js";const L=class H extends V{constructor(...e){let t=e[0]??{};t instanceof Float32Array&&(F(_,"use new MeshGeometry({ positions, uvs, indices }) instead"),t={positions:t,uvs:e[1],indices:e[2]}),t={...H.defaultOptions,...t};const s=t.positions||new Float32Array([0,0,1,0,1,1,0,1]),i=t.uvs||new Float32Array([0,0,1,0,1,1,0,1]),a=t.indices||new Uint32Array([0,1,2,0,2,3]),r=t.shrinkBuffersToFit,n=new M({data:s,label:"attribute-mesh-positions",shrinkToFit:r,usage:S.VERTEX|S.COPY_DST}),u=new M({data:i,label:"attribute-mesh-uvs",shrinkToFit:r,usage:S.VERTEX|S.COPY_DST}),h=new M({data:a,label:"index-mesh-buffer",shrinkToFit:r,usage:S.INDEX|S.COPY_DST});super({attributes:{aPosition:{buffer:n,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:u,format:"float32x2",stride:2*4,offset:0}},indexBuffer:h,topology:t.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(e){this.attributes.aPosition.buffer.data=e}get uvs(){return this.attributes.aUV.buffer.data}set uvs(e){this.attributes.aUV.buffer.data=e}get indices(){return this.indexBuffer.data}set indices(e){this.indexBuffer.data=e}};L.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let tt=L;function E(o,e){if(o.texture===B.WHITE&&!o.fill)return A.shared.setValue(o.color).toHex();if(o.fill){if(o.fill instanceof N){const t=o.fill,s=e.createPattern(t.texture.source.resource,"repeat"),i=t.transform.copyTo(k.shared);return i.scale(t.texture.frame.width,t.texture.frame.height),s.setTransform(i),s}else if(o.fill instanceof D){const t=o.fill;if(t.type==="linear"){const s=e.createLinearGradient(t.x0,t.y0,t.x1,t.y1);return t.gradientStops.forEach(i=>{s.addColorStop(i.offset,A.shared.setValue(i.color).toHex())}),s}}}else{const t=e.createPattern(o.texture.source.resource,"repeat"),s=o.matrix.copyTo(k.shared);return s.scale(o.texture.frame.width,o.texture.frame.height),t.setTransform(s),t}return J("FillStyle not recognised",o),"red"}class et extends q{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return F(_,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return F(_,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return F(_,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return F(_,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return F(_,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners();for(const t in this.chars)this.chars[t].texture.destroy();this.chars=null,e&&(this.pages.forEach(t=>t.texture.destroy(!0)),this.pages=null)}}function R(o){if(o==="")return[];typeof o=="string"&&(o=[o]);const e=[];for(let t=0,s=o.length;t<s;t++){const i=o[t];if(Array.isArray(i)){if(i.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);if(i[0].length===0||i[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const a=i[0].charCodeAt(0),r=i[1].charCodeAt(0);if(r<a)throw new Error("[BitmapFont]: Invalid character range.");for(let n=a,u=r;n<=u;n++)e.push(String.fromCharCode(n))}else e.push(...Array.from(i))}if(e.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return e}class Y extends et{constructor(e){super(),this.resolution=1,this.pages=[],this._padding=4,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const t=e,s=t.style.clone();t.overrideFill&&(s._fill.color=16777215,s._fill.alpha=1,s._fill.texture=B.WHITE,s._fill.fill=null);const i=s.fontSize;s.fontSize=this.baseMeasurementFontSize;const a=W(s);t.overrideSize?s._stroke&&(s._stroke.width*=this.baseRenderedFontSize/i):s.fontSize=this.baseRenderedFontSize=i,this._style=s,this._skipKerning=t.skipKerning??!1,this.resolution=t.resolution??1,this._padding=t.padding??4,this.fontMetrics=I.measureFont(a),this.lineHeight=s.lineHeight||this.fontMetrics.fontSize||s.fontSize}ensureCharacters(e){var g,m;const t=R(e).filter(v=>!this._currentChars.includes(v)).filter((v,w,x)=>x.indexOf(v)===w);if(!t.length)return;this._currentChars=[...this._currentChars,...t];let s;this._currentPageIndex===-1?s=this._nextPage():s=this.pages[this._currentPageIndex];let{canvas:i,context:a}=s.canvasAndContext,r=s.texture.source;const n=this._style;let u=this._currentX,h=this._currentY;const d=this.baseRenderedFontSize/this.baseMeasurementFontSize,c=this._padding*d,p=n.fontStyle==="italic"?2:1;let l=0,f=!1;for(let v=0;v<t.length;v++){const w=t[v],x=I.measureText(w,n,i,!1);x.lineHeight=x.height;const b=p*x.width*d,K=x.height*d,P=b+c*2,T=K+c*2;if(f=!1,w!==`
`&&w!=="\r"&&w!=="	"&&w!==" "&&(f=!0,l=Math.ceil(Math.max(T,l))),u+P>512&&(h+=l,l=T,u=0,h+l>512)){r.update();const C=this._nextPage();i=C.canvasAndContext.canvas,a=C.canvasAndContext.context,r=C.texture.source,h=0}const U=b/d-(((g=n.dropShadow)==null?void 0:g.distance)??0)-(((m=n._stroke)==null?void 0:m.width)??0);if(this.chars[w]={id:w.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:U,kerning:{}},f){this._drawGlyph(a,x,u+c,h+c,d,n);const C=r.width*d,z=r.height*d,$=new Z(u/C*r.width,h/z*r.height,P/C*r.width,T/z*r.height);this.chars[w].texture=new B({source:r,frame:$}),u+=Math.ceil(P)}}r.update(),this._currentX=u,this._currentY=h,this._skipKerning&&this._applyKerning(t,a)}get pageTextures(){return F(_,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(e,t){const s=this._measureCache;for(let i=0;i<e.length;i++){const a=e[i];for(let r=0;r<this._currentChars.length;r++){const n=this._currentChars[r];let u=s[a];u||(u=s[a]=t.measureText(a).width);let h=s[n];h||(h=s[n]=t.measureText(n).width);let d=t.measureText(a+n).width,c=d-(u+h);c&&(this.chars[a].kerning[n]=c),d=t.measureText(a+n).width,c=d-(u+h),c&&(this.chars[n].kerning[a]=c)}}}_nextPage(){this._currentPageIndex++;const e=this.resolution,t=O.getOptimalCanvasAndContext(512,512,e);this._setupContext(t.context,this._style,e);const s=e*(this.baseRenderedFontSize/this.baseMeasurementFontSize),i=new B({source:new Q({resource:t.canvas,resolution:s,alphaMode:"premultiply-alpha-on-upload"})}),a={canvasAndContext:t,texture:i};return this.pages[this._currentPageIndex]=a,a}_setupContext(e,t,s){t.fontSize=this.baseRenderedFontSize,e.scale(s,s),e.font=W(t),t.fontSize=this.baseMeasurementFontSize,e.textBaseline=t.textBaseline;const i=t._stroke,a=(i==null?void 0:i.width)??0;if(i&&(e.lineWidth=a,e.lineJoin=i.join,e.miterLimit=i.miterLimit,e.strokeStyle=E(i,e)),t._fill&&(e.fillStyle=E(t._fill,e)),t.dropShadow){const r=t.dropShadow,n=A.shared.setValue(r.color).toArray(),u=r.blur*s,h=r.distance*s;e.shadowColor=`rgba(${n[0]*255},${n[1]*255},${n[2]*255},${r.alpha})`,e.shadowBlur=u,e.shadowOffsetX=Math.cos(r.angle)*h,e.shadowOffsetY=Math.sin(r.angle)*h}else e.shadowColor="black",e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0}_drawGlyph(e,t,s,i,a,r){const n=t.text,u=t.fontProperties,h=r._stroke,d=((h==null?void 0:h.width)??0)*a,c=s+d/2,p=i-d/2,l=u.descent*a,f=t.lineHeight*a;r.stroke&&d&&e.strokeText(n,c,p+f-l),r._fill&&e.fillText(n,c,p+f-l)}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{canvasAndContext:t,texture:s}=this.pages[e];O.returnCanvasAndContext(t),s.destroy(!0)}this.pages=null}}function st(o,e,t){const s={width:0,height:0,offsetY:0,scale:e.fontSize/t.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};s.offsetY=t.baseLineOffset;let i=s.lines[0],a=null,r=!0;const n={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},u=l=>{const f=i.width;for(let g=0;g<n.index;g++){const m=l.positions[g];i.chars.push(l.chars[g]),i.charPositions.push(m+f)}i.width+=l.width,r=!1,n.width=0,n.index=0,n.chars.length=0},h=()=>{let l=i.chars.length-1,f=i.chars[l];for(;f===" ";)i.width-=t.chars[f].xAdvance,f=i.chars[--l];s.width=Math.max(s.width,i.width),i={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,s.lines.push(i),s.height+=t.lineHeight},d=t.baseMeasurementFontSize/e.fontSize,c=e.letterSpacing*d,p=e.wordWrapWidth*d;for(let l=0;l<o.length+1;l++){let f;const g=l===o.length;g||(f=o[l]);const m=t.chars[f]||t.chars[" "];if(/(?:\s)/.test(f)||f==="\r"||f===`
`||g){if(!r&&e.wordWrap&&i.width+n.width-c>p?(h(),u(n),g||i.charPositions.push(0)):(n.start=i.width,u(n),g||i.charPositions.push(0)),f==="\r"||f===`
`)i.width!==0&&h();else if(!g){const b=m.xAdvance+(m.kerning[a]||0)+c;i.width+=b,i.spaceWidth=b,i.spacesIndex.push(i.charPositions.length),i.chars.push(f)}}else{const x=m.kerning[a]||0,b=m.xAdvance+x+c;n.positions[n.index++]=n.width+x,n.chars.push(f),n.width+=b}a=f}return h(),e.align==="center"?it(s):e.align==="right"?nt(s):e.align==="justify"&&rt(s),s}function it(o){for(let e=0;e<o.lines.length;e++){const t=o.lines[e],s=o.width/2-t.width/2;for(let i=0;i<t.charPositions.length;i++)t.charPositions[i]+=s}}function nt(o){for(let e=0;e<o.lines.length;e++){const t=o.lines[e],s=o.width-t.width;for(let i=0;i<t.charPositions.length;i++)t.charPositions[i]+=s}}function rt(o){const e=o.width;for(let t=0;t<o.lines.length;t++){const s=o.lines[t];let i=0,a=s.spacesIndex[i++],r=0;const n=s.spacesIndex.length,h=(e-s.width)/n;for(let d=0;d<s.charPositions.length;d++)d===a&&(a=s.spacesIndex[i++],r+=h),s.charPositions[d]+=r}}class at{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(e,t){var r;let s=`${t.fontFamily}-bitmap`,i=!0;if(t._fill.fill&&(s+=t._fill.fill.uid,i=!1),!y.has(s)){const n=new Y({style:t,overrideFill:i,overrideSize:!0,...this.defaultOptions});n.once("destroy",()=>y.remove(s)),y.set(s,n)}const a=y.get(s);return(r=a.ensureCharacters)==null||r.call(a,e),a}getLayout(e,t){const s=this.getFont(e,t);return st(e.split(""),t,s)}measureText(e,t){return this.getLayout(e,t)}install(...e){var h,d,c,p;let t=e[0];typeof t=="string"&&(t={name:t,style:e[1],chars:(h=e[2])==null?void 0:h.chars,resolution:(d=e[2])==null?void 0:d.resolution,padding:(c=e[2])==null?void 0:c.padding,skipKerning:(p=e[2])==null?void 0:p.skipKerning},F(_,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const s=t==null?void 0:t.name;if(!s)throw new Error("[BitmapFontManager] Property `name` is required.");t={...this.defaultOptions,...t};const i=t.style,a=i instanceof X?i:new X(i),r=a._fill.fill!==null&&a._fill.fill!==void 0,n=new Y({style:a,overrideFill:r,skipKerning:t.skipKerning,padding:t.padding,resolution:t.resolution,overrideSize:!1}),u=R(t.chars);return n.ensureCharacters(u.join("")),y.set(`${s}-bitmap`,n),n.once("destroy",()=>y.remove(`${s}-bitmap`)),n}uninstall(e){const t=`${e}-bitmap`,s=y.get(t);s&&(y.remove(t),s.destroy())}}const dt=new at,j=class G extends tt{constructor(...e){super({});let t=e[0]??{};typeof t=="number"&&(F(_,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),t={width:t,height:e[1],verticesX:e[2],verticesY:e[3]}),this.build(t)}build(e){e={...G.defaultOptions,...e},this.verticesX=this.verticesX??e.verticesX,this.verticesY=this.verticesY??e.verticesY,this.width=this.width??e.width,this.height=this.height??e.height;const t=this.verticesX*this.verticesY,s=[],i=[],a=[],r=this.verticesX-1,n=this.verticesY-1,u=this.width/r,h=this.height/n;for(let c=0;c<t;c++){const p=c%this.verticesX,l=c/this.verticesX|0;s.push(p*u,l*h),i.push(p/r,l/n)}const d=r*n;for(let c=0;c<d;c++){const p=c%r,l=c/r|0,f=l*this.verticesX+p,g=l*this.verticesX+p+1,m=(l+1)*this.verticesX+p,v=(l+1)*this.verticesX+p+1;a.push(f,g,m,g,v,m)}this.buffers[0].data=new Float32Array(s),this.buffers[1].data=new Float32Array(i),this.indexBuffer.data=new Uint32Array(a),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};j.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let lt=j;export{et as A,dt as B,tt as M,lt as P,E as a,st as g};
